djun  13641028753
hjnan 13241185256
hjnanxin 15321562912
liunq   18910318794
wangcm   15822982507
wangyi  13911048782   01063627822
xbin  18601244436

/usr/local/bin/memcached -d -m 2048 -u root -l 111.67.194.166 -p 12000 -c 1000 -P /tmp/memcached.pid

6226230036219812 512800

题目列表 > 竞价

时间限制: 1000ms 内存限制: 256MB

描述
Alice和Bob都要向同一个商人购买钻石。商人手中有 N 颗钻石，他会将它们一颗颗地卖给他们，Alice和Bob通过竞价的方式来决定钻石的归属。具体的过程如下：商人首先指定其中一个人开始报价，之后两人轮流报价，要求是一定要比对方报的价格更高。任何时候，如果一个人不愿出价或者出不起价钱时，可以宣布弃权，则对手以最后一次报的价格将钻石买下。当然，如果两人都没钱，商人是不会卖钻石的。首次报价至少为 1，并且只能报整数的价钱。

Alice和Bob特别爱攀比，因此他们都希望能比对方买到更多的钻石。Alice和Bob各自带了 CA 和 CB 的钱用于竞拍钻石。此外，Alice和商人有很不错的私人关系，因此商人总是会让Alice先报价。现在请问，在Alice和Bob都用最优策略的情况下，谁能买到更多钻石？假设双方都知道对方手中的现金数量，以及商人将要拍卖的钻石数量 N。

输入
输入文件包含多组测试数据。

第一行，给出一个整数T，为数据组数。接下来依次给出每组测试数据。

每组数据为三个用空格隔开的整数 N，CA，CB，表示钻石的数量，以及双方带的现金数量。

输出
对于每组测试数据，输出一行"Case #X: Y"，其中X表示测试数据编号，Y的取值为{-1, 0, 1}，-1表示Alice买到的钻石会比Bob少，0表示两人能买到一样多，1表示Alice能买到更多钻石。所有数据按读入顺序从1开始编号。

数据范围
1 ≤ T ≤ 1000

小数据：0 ≤ N ≤ 10; 0 < CA, CB ≤ 10

大数据：0 ≤ N ≤ 105; 0 < CA, CB ≤ 106



样例输入
2
4 3 5
7 4 7
样例输出
Case #1: 0
Case #2: 1


题目列表 > 相似字符串

时间限制: 4000ms 内存限制: 256MB

描述
对于两个长度相等的字符串，我们定义其距离为对应位置不同的字符数量，同时我们认为距离越近的字符串越相似。例如，“0123”和“0000”的距离为 3，“0123”和“0213”的距离则为 2，所以与“0000”相比，“0213”和“0123”最相似。

现在给定两个字符串 S1 和 S2，其中 S2 的长度不大于 S1。请在 S1 中寻找一个与 S2 长度相同的子串，使得距离最小。

输入
输入包括多组数据。第一行是整数 T，表示有多少组测试数据。每组测试数据恰好占两行，第一行为字符串 S1，第二行为 S2。所有字符串都只包括“0”到“9”的字符。

输出
对于每组测试数据，单独输出一行“Case #c: d”。其中，c 表示测试数据的编号（从 1 开始），d 表示找到的子串的最小距离。

数据范围
1 ≤ T ≤ 100

小数据：字符串长度不超过 1000

大数据：字符串长度不超过 50000

样例输入
3
0123456789
321
010203040506070809
404
20121221
211
样例输出
Case #1: 2
Case #2: 1
Case #3: 1

题目列表 > 仙剑5前传之璇光殿

时间限制: 4000ms 内存限制: 256MB

描述
仙剑是一款经典的RPG游戏，最近又推出了仙剑5前传。Alice身为忠实的仙剑粉丝，当然是在第一时间就开始玩了。迷宫以及各类小游戏是仙剑系列的一大传统，这次也不例外。而且还增加了称号系统，玩家如果在满足一定条件下通过迷宫或是完成小游戏，都可以获得相应的称号奖励。Alice虽然智商也不算太低，顺利的完成游戏还是没什么问题的，但是某些称号对于她来说好像就比较困难，所以她来找你帮忙。

在这个迷宫中，有很多魔法台需要关闭，也有很多宝箱可以捡。你最主要的目标就是关闭所有的魔法台，一旦所有魔法台都被关闭后，立刻通关。这个迷宫中有两个称号可以获得，一个要求拣到所有的宝箱，另一个要求在一定时间内完成。

为了让迷宫变得更加复杂，迷宫中还有两种特殊的法阵。第一种法阵是加速阵，可以瞬间使玩家的移动速度提高5m/s（初始速度为30m/s）。第二种是五灵阵，玩家必须按照五灵相克相生的关系来选择开启适当的阵法才可顺利通过。若玩家顺利通过五灵阵，则也可获得5m/s的速度提升，反之，用户则会被困在原地5秒钟。幸运的是，Alice在网上找到了攻略，所以在通过五灵阵时，她只需要查看一下即可保证顺利通过。不过介于她的思考速度，她需要3秒钟来查看攻略。

Alice想知道如果她想要拣到所有的宝箱，那么最快多长时间能够通过这个迷宫呢？

输入
输入数据的第一行包含一个整数 T，表示数据组数。

接下来有 T 组数据，每组数据中：

第一行包含两个整数 N, M，表示迷宫中节点个数以及边数。节点由 1 到 N 标号。

接下来的 M 行每行包含三个整数 a, b, len，表示节点 a 和节点 b 之间有一条长度为 len 米的路。

接下来的一行包含一个整数 NM，表示魔法台的个数。下一行 NM 个整数，表示魔法台所在的节点编号。

接下来的一行包含一个整数 NT，表示宝箱的个数。下一行 NT 个整数，表示宝箱所在的节点编号。

接下来的一行包含一个整数 NS，表示加速阵的个数。下一行 NS 个整数，表示加速阵所在的节点编号。

接下来的一行包含一个整数 NR，表示五灵阵的个数。下一行 NR 个整数，表示五灵阵所在的节点编号。

最后一行包含一个整数 S，表示玩家的出发节点编号。



输出
对于每组数据，输出一行"Case #X: Y",其中 X 为数据组数编号，从 1 开始，Y 为通过该迷宫的最短时间，四舍五入保留5位小数。

数据范围
1 ≤ T ≤ 10

0 ≤ len ≤ 1000

小数据：

1 ≤ N ≤ 30

0 ≤ M ≤ 200

1 ≤ NM ≤ 3

0 ≤ NT, NS, NR ≤ 3

大数据：

1 ≤ N ≤ 100

0 ≤ M ≤ 2000

1 ≤ NM ≤ 4

0 ≤ NT, NS, NR ≤ 4

提示
1. 每个节点上至多有一个特殊的物品。

2. 当你经过魔法台，加速阵以及宝箱时，可以选择不触发它。

3. 每个法阵都是一次性的，不会被多次触发。

样例输入
2
2 1
1 2 30
1
2
0

0

0

1
3 2
1 2 100
2 3 100
1
3
0

0

1
2
1
样例输出
Case #1: 1.00000
Case #2: 9.19048

题目列表 > 管道系统

时间限制: 5000ms 内存限制: 256MB

描述
你正在参与一项输油管道的项目，此项目的目标是架设一组输油管道系统，使得从源头到目的地输送的石油流量最大。如果直接从源头架设管道到目的地，一旦管道有损坏，将无法输送石油。为了增强管道系统抵抗破坏的能力，你决定设置 N - 2 个中间节点，从而把管道分散开来。

源头和目的地可以视为特殊的节点，他们的编号分别为 1 和 N，而其他的中间节点的标号为 2 到 N - 1。每条管道有特定的流量限制 c，石油可以以不超过 c 的速率在管道内流动。两个节点之间至多由一条管道连接，也就是说这两个节点之间单位时间内流动的石油不超过 c。

现在你们已经选定了 N 个节点，并且制定好了建设计划。你想知道，每当一条管道建造完成，从节点 1 到节点 N 最大流量能够增加多少。

输入
输入包括多组数据。第一行是整数 T，表示有多少组测试数据。每组测试数据的第一行包括两个整数 N 和 M，表示节点的数量和将要建造的管道数量。接下来 M 行按建造顺序描述每条管道，每行包括三个整数 i, j, c，表示要在节点 i 和 j 之间建造一条容量为 c 的管道。

输出
对于每组测试数据，先输出一行“Case #c:”，其中 c 为测试数据编号（从 1 开始）。紧接着按建造顺序输出使得总流量增加的管道编号和相应的增加量，以一个空格隔开。

数据范围
1 ≤ T ≤ 100

0 ≤ M ≤ N(N - 1)/2

1 ≤ v ≠ u ≤ N

1 ≤ c ≤ 100

小数据：2 ≤ N ≤ 20

大数据：2 ≤ N ≤ 200



样例输入
3
2 1
1 2 3
4 5
1 2 9
2 3 7
3 4 6
2 4 4
1 3 1
5 7
1 2 1
1 3 2
1 4 3
2 5 4
3 2 3
4 3 3
3 5 2
样例输出
Case #1:
1 3
Case #2:
3 6
4 3
5 1
Case #3:
4 1
5 2
6 1
7 2



题目列表 > 仙剑5前传之软星包子

时间限制: 1000ms 内存限制: 256MB

描述
仙剑是一款经典的RPG游戏，最近又推出了仙剑5前传。Alice身为忠实的仙剑粉丝，当然是在第一时间就开始玩了。迷宫以及各类小游戏是仙剑系列的一大传统，这次也不例外。而且还增加了称号系统，玩家如果在满足一定条件下通过迷宫或是完成小游戏，都可以获得相应的称号奖励。Alice虽然智商也不算太低，顺利的完成游戏还是没什么问题的，但是某些称号对于她来说好像比较困难，所以她来找你帮忙。

仙剑5前传中增加了软星包子这种很萌的NPC，它散落在世界各地，你每找到一个，都可以挑战他，挑战成功可以拿到一些卡片。挑战具体说来就是一个记忆力游戏，有 N 种卡片，每种两张，总共 2N 张卡片面朝下放置。玩家可以点击面朝下的卡片并将其翻面。当有两张卡片正面朝上时，如果这两张卡片是同一种，则将这两张卡片收走，否则的话，再将这两张卡片面朝下放置在原位。

Alice的记忆力很差，只能记住 K 张卡片（包括刚刚翻开的）。她的策略如下：

* 当没有卡片正面朝上时：

   * 如果她记住的卡片中有两张是同一种的，那就翻开那两张卡片；

   * 否则，她随机的翻开一张她不知道的卡片。

* 当有一张卡片正面朝上时：

   * 如果她记得另一张同样的卡片在哪里，就直接翻开那张；

   * 否则，她随机的翻开一张她不知道的卡片。

Alice想知道，她期望要点多少次才可以完成这个小游戏。

输入
输入数据的第一行包含一个整数 T，表示数据组数。

接下来有 T 组数据，每组数据中有一行，包含两个整数 N, K。

输出
对于每组数据，输出一行"Case #X: Y"，其中 X 为数据组数编号，从 1 开始，Y 为期望的步数。

绝对误差在1e-6以内或相对误差在1e-8以内即可。

数据范围
1 ≤ T ≤ 10

1 ≤ K ≤ 10

小数据：1 ≤ N ≤ 100

大数据：1 ≤ N ≤ 100000

提示
下面是一种可能的游戏过程，用来解释Alice可以记住 K 张卡片这一点：

假设N = 5, K = 3

已经翻开的卡片	刚刚翻开的卡片	Alice记住的卡片	解释
-	A0	A0	
A0	B0	A0, B0	
-	C0	A0, B0, C0	
C0	B1	B0, C0, B1	
-	B0, B1	C0, B0, B1	B0和B1都在记忆中，直接翻开移除
-	A1	C0, A1	
A1	D0	C0, A1, D0	
-	E0	A1, D0, E0	
E0	E1	D0, E0, E1	碰巧翻到两张一样的，E0和E1移除
-	D1	D0, D1	
D1	D0	D1, D0	Alice记得D0，D0和D1移除
-	A1	A1	
继续……

样例输入
2
2 1
3 3
样例输出
Case #1: 8.000000
Case #2: 9.000000

题目列表 > 集会

时间限制: 2000ms 内存限制: 256MB

描述
在一条河的一侧，分布着 N 个村庄。这些村庄平日里需要一些贸易往来，然而商人们来回走遍每一座村庄是非常辛苦的，于是他们决定每个月都在河边举行一次集会，大家都来集会上购买需要的物品。然而在集会地点的选择上，大家却有分歧，因为谁都不愿意集会的地点离自己村庄非常远。经过一番激烈的讨论之后，大家决定要将集会地点挑选在这样一个位置：它离最远的村庄的距离要尽可能的近。

我们把河看做一条足够长的直线，河岸就是平面坐标系上 y = 0 的这条线，y < 0 的区域是河水，而所有村庄都在 y ≥ 0 的区域里。现在给出所有村庄的平面坐标，你要在河岸上找到这样一个位置，使得它到所有村庄的最远距离最小。

输入
输入文件包含多组测试数据。

第一行，给出一个整数 T，为数据组数。接下来依次给出每组测试数据。

每组数据的第一行是一个整数 N，表示村庄的数量。接下来 N 行，每行有两个实数 xi 和 yi，表示每一个村庄的坐标。

输出
对于每组测试数据，输出一行"Case #X: Y"，其中 X 表示测试数据编号，Y 表示集会地点的 x 坐标值，要求与正确答案的绝对误差在10-6以内。所有数据按读入顺序从 1 开始编号。

数据范围
小数据：T ≤ 100, 0 < N ≤ 50, 0 ≤ |xi|, yi ≤ 10000

大数据：T ≤ 10, 0 < N ≤ 50000, 0 ≤ |xi|, yi ≤ 10000

样例输入
1
5
0 8
1 6
4 4
-5 7
-6 1
样例输出
Case #1: -1.000000





1，你喜欢网购不？
2，你购物一般是网购还是到实体店购买？
3，如果实体店有自己的网站你会去看吗？

恩恩，可以帮我个忙吗，我是做问卷调查的，问您几个问题可以吧
那好吧，打扰了
放心，我不是推销的，只是问几个问题，调查一下，没有恶意的
您好，我可以问你3个问题不，我是做问卷调查的


1--	23岁 男  工作
	1--喜欢
	2--网购
	3--会

2--     23岁 男  工作
	1--一般吧 偶尔 
	2--实体多些
	3--看情况 有时间可以

3--     27岁 女 工作
	1--没有购物经验
	2--实体店
	3--会上网看

4--     19岁  女 学生
	1--没有
	2--实体店
	3--会

5--     23岁 女 工作
	1--还行吧
	2--都有
	3--会


32 位机上根据下面的代码，问哪些说法是正确的？
signed char a = 0xe0;
unsigned int b = a;
unsigned char c = a;
A. a>0 && c>0 为真 B. a == c 为真 C. b 的十六进制表示是：0xffffffe0 D. 上面都不对
分析：坑爹丫，有木有！10 个人 9 个这个恐怕都不敢确定！(敢肯定的要么是高手，要么就是错的！) B me 认为是错的，一个 uchar 和一个 schar 比较，真的就是一个字节在比较吗？C me 认为是对的，将一个 schar 赋值给一个 uint，要不要符号扩展呢？是绝对会还是可能会呢？细节到底是神马？O__O"…A 貌似比较确定，肯定是错的，肯定？
揭露真相：A 确实是错的，B 也是错的，C 是对的，所以 D 也是错的。理由？A 错是因为，a 是负数，c 是正数，即使跟 0 比较要转换到 int(后面暂不区分转换和类型提升，总之就是类型变了)，也是一负一正，所以 A 错。B 呢？是说一正一负不会相等，难道是因为这吗？难道不是吗？首先说 a 和 c 的二进制表示一模一样，都是 0xe0，那么比较就不相等？！是的，比较的时候全部转换为 int，所以呢，a 还是作为一个负数存在，c 作为一个正数存在，于是就不相等了，所以 B 错。C 肿么就对了？a 是一个 schar，赋值给 uint 的 b，前若干个字节不是补 0 吗？首先 schar 转换为 int，然后 int 转换成 uint，所以最初是符号扩展，然后一个 int 赋值给了 uint，C correct！me 曾经要写一篇关于c的类型以及指针的 blog，不过最后没有完成，不过还是可以参考一下的。
下面哪些选项能编译通过？


int i;
char a[10;
string f();
string g(string &str);

A. if(!!i){f();} B. g(f()); C. a=a+1; D. g("abc");
分析：再次坑爹有木有！(其实 me 比较确信这道题，是坑别人的爹，O__O"…)A 绝对是正确的，C 绝对是错的，D 基本肯定是错的，那 B 呢？要么 error ，要 warning！如果是 warning 但是没有 error ，这算神马情况呢？B 确实不应该选，至少语义上不该选！f() 返回一个临时量，然后传给 g 函数，而 g 的参数是非 const 引用，是不能引用临时量的！为嘛，如果 g 中修改了传进来的 string，那么会是怎么一回事呢？修改了一个临时量的值？那这意义何在呢？但是如果将 g 的原型修改为 string g(const string&); 就是可以的，为么可以？访问(只读)临时量就是正确的？那必须的，比如 u 可能想知道 a+b 的结果是多少，然后输出！a+b 的结果就是一个临时量。如果说修改 a+b 的结果，这是神马个逻辑？！
真相：C 错是以为 a 是一个地址常量，不可能再被赋值。D 为嘛错呢？"abc" 的类型可是 const char* 呢，是个常量指针呢！(可以用来初始化 string。)
int a[10]; 问下面哪些不可以表示 a[1] 的地址？
A. a+sizeof(int) B. &a[0]+1 C. (int*)&a+1 D. (int*)((char*)&a+sizeof(int))
分析：奇葩丫！(其实并不奇葩！)腾讯的题目有时候出的的确有水平丫，虽然出的太有水平了分就考不高了。me 想哭丫，想来想去还是在 A 和 B 中选错了，%>_<%，当时还特意提醒自己来着的，O__O"…c++ 中的 sort 如何用来排序 a 数组呢？sort(a, a+N); 或是 sort(a, a+sizeof(a)/sizeof(a[0])); 当时懵了，实际上 a+1，就是 a[1] 的地址呢！a 的类型是 int[10]，a+1 和一个 int* 类型的 +1 效果一样，都表示偏移 1 个元素，所以 A 不能表示。(选错误的！) C 能表示是因为取了首地址作为一个 int* 然后 +1，就是偏移一个元素，所以不选。B 肿么说呢，me 一直一位&a[0] 是一个普普通通的地址，+1 就是 +1个字节，实际上是 +1 个元素！D 也能表示？将 a 的首地址转换为一个 char* 指针，这个时候 +1 是偏移一个 char，也就是一个字节，实际上应该偏移 sizeof(int) 个字节才能到达 a[1]，所以 D 可以表示(不选)。不多说了。(如果是二维数组是不是会更懵呢，O__O"…)
问下面的数据都存放在哪些存储区？


int main()
{
    char *p = "hello,world";
    return 0;
}

A. ... B. ... C. 栈和常量区 D. 栈和堆
分析："hello,world" 是常量，赶脚应该就是 C 吧，应该大家感觉都一样。这里不涉及什么堆的事。
假设在一个 32 位 little endian 的机器上运行下面的程序，结果是多少？


#include <stdio.h>
int main()
{
    long long a = 1, b = 2, c = 3;
    printf("%d %d %d\n", a, b, c);
    return 0;
}

A. ... B. ... C. ... D. ...
分析：貌似问题没有想的那么简单。如果说运行结果，很简单，有人是 1 0 2；有人是 1 2 3。涉及到 little/big endian 和参数入栈的问题，me 表示现在有点无能为力，O__O"…
下面哪些函数调用必须进入内核才能完成？
A. fopen B. exit C. memcpy D. strlen
分析：有些无能为力。A 是要打开文件的，貌似设计很多内核操作丫；exit 是退出进程，结束进程，应该也要深入内核。memcpy ，me 一直犹豫用户区的数据拷贝要不要通过内核。strlen me 感觉关系不大。
内存管理中的 LRU 方法是用来管理神马的？
A. 虚拟内存的分配 B. 虚拟内存的释放 C. 物理内存的分配 D. 物理内存的释放
分析：貌似是用来关系物理块的，后面的填空题正好有说，O__O"…
关于DMA 的说法，哪些是错误的？
A. DMA，Direct Memory Acess 直接存储器访问，使得不同的速度的硬件设备可以直接通信，不通过 CPU 干预；
B. DMA 访问的时候需要从 CPU 那里夺得总线控制权，然后...
C. DMA 速度快；
D. DMA 不需要中断控制，CPU 管理不要它；
死锁发生的必要条件？
A. 互斥条件 B. 请求和保持 C. 不可剥夺 D. 循环等待
分析：ABCD 就是死锁的四个必要条件，操作系统书上貌似说的很明确。
有两个线程，最初 n=0，一个线程执行 n++; n++; 另一个执行 n+=2; 问，最后可能的 n 值？
A. 1 B. 2 C. 3 D. 4
分析：D 顺序执行以下，就可以。B 的话，让后面一个执行到+2，但不要写结果，然后前一个执行完，然后写结果，为 2。C 3 的话，也好分析。A 不可能！肿么可能呢？肿么可能结果只为 1 呢？两个线程都会 +2，+1 何从谈起？先 +1，然后让后面的加法错了，然后结果写进去？前一个 ++n 都没执行的话，后一个又肿么会执行呢？总之不可能是 1 ！不可能！O__O"…(坚决不相信它可以。)
下面哪些说法正确？
A. 数组和链表都可以随机访问
B. 数组的插入和删除可以 O(1)
C. 哈希表么法范围检查
D. ...
分析：总之 ABD 给人的感觉是显而易见的错丫，有木有，所以排除法还是能用的！至于 hash 结构，确实也不可以范围检查，因为 key 映射为 value，完全将根据的 hash 函数，而这个函数一般不满足原来的单调性，实际上就应该满足！因为 hash 函数的设计是要 value 的映射随机、均匀！
基于比较的排序的时间复杂度下限是多少?
A. O(n) B. O(n^2) C. O(nlogn) D. ...
分析：貌似是数据结构上面的一个结论，基于比较的排序的时间复杂度不能比 O(nlogn) 地。
下面图的拓扑排序可能是？
A...
分析：对于知道拓扑排序的，应该很容易作答(me 有时候在怀疑自己理解的是否正确？！)。
求 n 个数中的最大值和最小值，最少的比较次数是？
A. 4n/3 B. 2n-2 C. n-1 D. 3n/2
分析：虽然 me 不知道很高深的算法，但是 me 想丫，如果是 2 1 3 4 5 6 这样的序列，u 认为最少是多少次呢？me 感觉是 n-1 。但是，题目也许是另外一个意思，也就是对于普通的序列，求最大值和最小值，能将比较次数降到多少？(me 貌似见到过一些方法，但是忘了，O__O"…)
一棵二叉树的先序遍历是 f b a c d e g h，中序遍历是 a b d c e f g h，问后序遍历是神马？
A. ... B. ... C. ... D. ...
分析：构建二叉树，然后看看后序遍历是神马？a d e c b h g f，O__O"…，突然感觉一不小心 g f 和 fg 就写反了，me 应该没有吧？！
网卡、交换机、路由器和 UDP 分别工作网络的哪些层？
A. ...
B. ...
C. ...
D. ....
分析：值根据 UDP 在传输层，me 就选出答案了：物理层、数据链路层、网络层和传输层。
子网掩码 25..255.255.224 可以将网络 x.x.x.x 分成多少个子网？
A. ... B. ... C. 8 D. 32
分析：224 = 128+64+32 = 1110 0000 B，me 一看，后面 5 个 0 ，就是 2^5 = 32 吧？
TCP协议栈的定时器有哪些？
A. ... B. ... C. ... D. ...
分析：不会的路过。
高内聚和低耦合，下面哪个耦合度最高？
A. 通过函数参数传递...
B. 一个函数修改另外一个函数中的数据；
C. 通过全局变量...
D. 通过指示器...
分析：一看全局变量，就是它无疑了。O__O"…
关于访问，下面哪些是后台绝对不会执行的？
A. 本地查查 DNS，是否有 sinaapp.com 的 ip；
B. 通过 cn. 查找 ip；
C. 通过 com. 查找 ip；
D. 浏览器发送 http get 请求；
D. 服务器回送 xxx.jpg；
分析：蒙也是蒙 B，O__O"…
在一个 big endian 的 32 位的计算机上，b 的结果是？(该处 1 个空)


unsigned int a = 0x1234;
char b = *((char*)&a);

分析：想不到又一个 big/little endian 的问题。这个结果，me 还比较确定写，就是 0。uint 是 4 个字节，0x1234 的完整表示是 0x 00 00 12 34，因为是 big endian，所以，所以 &(取地址) 的话，如果当字节看的话，取到了最左边 00 字节的地址，一定要转换成 char 看的话，值就是 0。
一个有 800 个结点的完全二叉树，问有多少个叶子结点？(该处 1 个空)
虽然 me 忘记是神马公式计算了，只感觉和 n/2 有关系。然后随便画几个试试，就可以找出来 (n+1)/2 的规律来，所以 400。
下面 get 是求一个二维数组元素的函数，请补全。( 1 个空)


#include <stdio.h>
#include <stdlib.h>
#define M 3
#define N 4
int get(int *a, int i, int j)
{
    int v;
    if(a == NULL || i<0 || i>=M || j<0 || j>=N) exit(1);    //
    v = *(a+i*N+j); // 这里有一个空
    return v;
}
int main()
{
    int a[M[N = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    int v;
    v = get(a, 2, 1);
    printf("a[2][1] == %d\n", v );
    return 0;
}

分析：差点写错了，还好迷途知返了，O__O"…
补全插入排序：(有 2 个空)


#include <stdio.h>
#include <stdlib.h>
int insert_sort(int *p, int count)
{
    int i, j, tmp;
    if(p == NULL || count < 0) return 0;    //
    for(i=1; i<count; i++){
        tmp = p[i;
        j = i-1;
        while(j>=0 && p[j>tmp){    // 此处判断条件一个空
            p[j+1 = p[j;
            --j;
        }
        p[j+1 = tmp;   // 此处一个空
    }
    return 1;
}
int main()
{
    int i, a[10 = {3, 2, 1, 7, 8, 10, 4, 5, 6, 9};
    insert_sort(a, 10);
    for(i=0; i<10; i++)
        printf("%d ", a[i);
    printf("\n");
    return 0;
}

分析：me 感觉 me 的代码还是比较工整的，肿么看，...
使用 FIFO 管理页面请求，如果分配的物理块 M = 3 或是 4，请求顺序如下：4 3 2 4 4 3 5 4 5 3 1 5 1 5 1 5 4，问两种情况下页面失效的次数各是多少？( 2 个空)
分析：7 和 7，这是 me 的结果。
一个网络图，问 Q 路由器到某个网络要进行跳转的下一个 ip 是多少？(有 1 个空)
分析：me 一下子就犹豫了，貌似赶脚也不是正确答案，就不多说了。
软件可靠性评估的两个指标是神马？( 2 个空)
分析：不会的路过。
